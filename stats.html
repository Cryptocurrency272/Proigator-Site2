// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract OriflameToken {
    string public name = "Oriflame";
    string public symbol = "orif$";
    uint8 public decimals = 18;
    uint256 public totalSupply = 30_000_000 * 10 ** 18;
    address public owner;

    mapping(address => uint256) public balanceOf;
    mapping(address => uint256) public claimable;
    mapping(address => mapping(address => uint256)) public allowance;

    // Referral tracking
    mapping(address => uint256) public totalReferredBNB;
    mapping(address => uint256) public totalCashbackEarned;
    mapping(address => uint256) public totalReferrals;
    mapping(address => address) public referrer;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Referral(address indexed from, address indexed ref, uint256 value);

    constructor() {
        owner = msg.sender;
        balanceOf[address(this)] = totalSupply;
        emit Transfer(address(0), address(this), totalSupply);
    }

    receive() external payable {
        buyTokens(address(0));
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        return true;
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        _transfer(msg.sender, to, amount);
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        uint256 allowed = allowance[from][msg.sender];
        require(allowed >= amount, "Allowance too low");
        allowance[from][msg.sender] = allowed - amount;
        _transfer(from, to, amount);
        return true;
    }

    function _transfer(address from, address to, uint256 amount) internal {
        require(balanceOf[from] >= amount, "Insufficient balance");
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        emit Transfer(from, to, amount);
    }

    function buyTokens(address _ref) public payable {
        require(msg.value > 0, "Send BNB to buy tokens");

        uint256 price = getCurrentPrice();
        uint256 tokens = (msg.value * 10 ** decimals) / price;

        require(balanceOf[address(this)] >= tokens, "Not enough tokens left");
        claimable[msg.sender] += tokens;
        balanceOf[address(this)] -= tokens;

        emit Transfer(address(this), msg.sender, tokens);

        // Referral logic
        if (_ref != address(0) && _ref != msg.sender && referrer[msg.sender] == address(0)) {
            referrer[msg.sender] = _ref;
            totalReferrals[_ref]++;
        }

        address direct = referrer[msg.sender];
        address indirect = referrer[direct];

        uint256 directBonus = (msg.value * 20) / 100;
        uint256 indirectBonus = (msg.value * 10) / 100;

        if (direct != address(0)) {
            totalReferredBNB[direct] += msg.value;
            totalCashbackEarned[direct] += directBonus;
            payable(direct).transfer(directBonus);
            emit Referral(msg.sender, direct, directBonus);
        }

        if (indirect != address(0)) {
            totalReferredBNB[indirect] += msg.value;
            totalCashbackEarned[indirect] += indirectBonus;
            payable(indirect).transfer(indirectBonus);
            emit Referral(msg.sender, indirect, indirectBonus);
        }
    }

    function claim() external {
        uint256 amount = claimable[msg.sender];
        require(amount > 0, "Nothing to claim");
        claimable[msg.sender] = 0;
        balanceOf[msg.sender] += amount;
        emit Transfer(address(this), msg.sender, amount);
    }

    function getCurrentPrice() public view returns (uint256) {
        uint256 sold = totalSupply - balanceOf[address(this)];
        if (sold < 3_000_000 * 10 ** 18) return 0.0001 ether; // Stage 1
        if (sold < 9_000_000 * 10 ** 18) return 0.0005 ether; // Stage 2
        if (sold < 15_000_000 * 10 ** 18) return 0.001 ether; // Stage 3
        if (sold < 21_000_000 * 10 ** 18) return 0.005 ether; // Stage 4
        if (sold < 27_000_000 * 10 ** 18) return 0.009 ether; // Stage 5
        return 0.02 ether; // Listing (Stage 6)
    }

    // Referral stats view functions
    function totalReferredBNBOf(address user) external view returns (uint256) {
        return totalReferredBNB[user];
    }

    function totalCashbackEarnedOf(address user) external view returns (uint256) {
        return totalCashbackEarned[user];
    }

    function totalReferralsOf(address user) external view returns (uint256) {
        return totalReferrals[user];
    }
}
